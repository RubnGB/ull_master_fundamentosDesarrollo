# Entrega 7
## Controlador de cámara

En esta práctica se ha implementado una aplicación en Unity2D en la que he reutilizado la escena 2D de la práctica anterior, incluyendo dos personajes A, B que se controlan desde el teclado:
## Controles para dos personajes
En primer lugar, es necesario modificar el script de movimiento del personaje para que corresponda al movimiento a través de las teclas awsd (aunque de momento la tecla s no se usará, ya que es un juego 2D de desplazamiento lateral en el que de momento no se pueden agachar los personajes) y tendremos otro script que corresponderá al movimiento a través de las flechas de dirección y que asociaremos al enemigo.
Tenemos que sustituir la tecla de espacio por la tecla W (flecha hacia arriba en el otro script) y crear una función que va a determinar la dirección del movimiento horizontal. En esta función, si se pulsa la tecla a (flecha izquierda en el otro script), dará un valor negativo a horizontalMovement, mientras que si pulsa la tecla d (flecha derecha en el otro script) dará un valor positivo a horizontalMovement. Cuando alguna de las dos teclas deje de pulsarse, pondrá a 0 horizontalMovement para que dejen de moverse.
Se han añadido también algunas animaciones al enemigo.


## Cámara A, B y grupal
Se van a contemplar los siguientes requisitos:
- Cámara con seguimiento al personaje A. Se debe configurar el seguimiento hacia adelante. Esta cámara es la que debe tener la máxima prioridad: a través del menú Cinemachine, se va a crear una cámara virtual 2D que siga (follow) al player. Como por defecto las cámaras se crean con prioridad 10, le he dado a esta cámara prioridad 15 para que siempre sea la de mayor prioridad. Para que haga el seguimiento ligeramente adelantado de la posición del objeto hay que aumentar y dar un valor positivo al parámetro Tracked Object Offset en el eje X.
- Cámara con seguimiento al personaje B. Debe configurarse una zona de seguimiento del personaje B más amplia que la de A: lo haremos de la misma forma pero en este caso seguirá al enemigo. Además, ampliaremos la soft zone a 1 tanto en el eje X como en el Y para que sea más amplia que la de A.
- Seleccionar un conjunto de teclas que permitan hacer el cambio de la cámara de los personajes a la cámara que sigue al grupo. (Habilitar/Deshabilitar el gameobject de la cámara virtual): Para facilitar el cambio entre cámaras, antes de continuar he creado el script llamado changingCamera.cs que activará la cámara A si pulsamos C, la cámara B si pulsamos X, y la cámara de grupo si pulsamos G. Además, cuando se active una cámara las demás serán desactivadas.
- Cámara que hace el seguimiento de ambos personajes: desde el menú de Cinemachine he creado una Target Group Camera, que ha añadido automáticamente una nueva cámara virtual con follow a Target Group Camera. Esto situará a la cámara de grupo en el centro de los dos objetos, alejándose o acercándose en función de lo cerca o lejos que estén los objetos (player y enemy) entre ellos para que siempre estén dentro de la cámara. Si modificamos el peso (weight dentro del targetGroup) y hacemos que uno de los dos objetos tenga un mayor valor, lo que hará la cámara grupal será centrarse más en dicho objeto de mayor valor. Además, para evitar que la cámara acapare solamente al objeto que tenga mayor peso, podemos aumentar su valor de radio para que la cámara se aleje según este valor. En resumen, el radio es como si hubiera un círculo alrededor del personaje que tiene que ser contenido en todo momento por la cámara, por tanto, cuanto mayor sea el radio, más área de la escena mostrará la cámara

En este gif podemos ver cómo la cámara activa es la que está siguiendo al player, luego cuando pulsamos la tecla X pasa a estar activa la cámara que está siguiendo al enemy, y finalmente cuando pulsamos la tecla G pasa a estar activa la cámara grupal. Además, en un determinado momento, mientras está activa la cámara grupal se aumenta el radio tanto del player como del enemy para que se abarque una mayor área de la escena.

![alt text](https://github.com/RubnGB/ull_master_fundamentosDesarrollo/blob/main/Practica7/gif_animation_07a.gif)

## Zonas de confinamiento y generación de impulsos
- Crear una zona de confinamiento de A que abarque toda la escena: creamos un objeto vacío, al que llamaré confiner, con un CompositeCollider2D con tipo de geometría polygons y que tenga marcado isTrigger para que no desplace al resto de elementos de la escena por estar superpuesto a ellos. Le agregamos también un Rigidbody Static y un BoxCollider2D que se abarque toda la escena. No se nos puede olvidar marcar el BoxCollider2D como Used By Composite.
Ahora nos vamos a la cámara que sigue al player y le añadimos la extensión Cinemachine Confiner, seleccionando como bounding shape 2D el composite Collider que hemos creado en el gameObject confiner. De esta forma cuando el personaje se salga de la zona de confinamiento la cámara dejará de seguirlo.
- Crear una zona de confinamiento de la cámara que persigue al objeto B que abarque solo una parte de la escena: el proceso es el mismo que en el punto anterior, pero haciendo que el BoxCollider2D sea más pequeño
- Añadir un objeto que genere una vibración en la cámara cuando el personaje A choca con él: voy a usar el cuadrado que tenía en la escena para tal fin. Dicho cuadrado tiene un Rigidbody2D dinámico y un box collider2D y le tenemos que añadir el component Cinemachine Collision Impulse Source. En este componente tendremos que seleccionar el tipo de señal que queremos que se aplique en la vibración de la cámara. En este caso hemos seleccionado el Handheld_normal_strong con una ganancia de 3 para que se note más la vibración y un sustain time de 0.8 para que dure el efecto algo más de tiempo. Además, hemos puesto en Trigger Object Filter que ignore la etiqueta Ground para que la cámara no vibre cuando colisione con el suelo. Una vez configurado este componente, a la cámara virtual que vamos a aplicar la vibración (la que sigue al player) hay que añadirle el componente Cinemachine Impulse Listener.
- Como extra, generar una vibración en la cámara cada vez que se pulse la tecla de disparo. Agregar un perfil de ruido a la cámara, y modificar las propiedades de amplitud y frecuencia al component Noise: en este caso he añadido el component Cinemachine Impulse Source al player (aunque podría haber creado un gameObject vacío para ello). He incrementado su amplitud y frecuencia para que la vibración sea más notoria y pueda ejecutarse más rápidamente. Además, he creado un nuevo script llamado impulseGenerator.cs que recibirá un objeto de tipo CinemachineImpulseSource que llamará a la función GenerateImpulse() cuando se pulse la tecla F. Respecto al component Noise no aparece vinculado al component Cinemachine Impulse Source, por lo que no se aplican sus valores al pulsar la tecla F. Como se encuentra integrado en la cámara virtual, lo que ocurre si lo activamos es que se genera una vibración continua a la cámara en la que se encuentra con la amplitud y frecuencia que le hayamos asignado.

En el gif podemos ver la vibración de la cámara que sigue a A cuando el player colisiona con el cuadrado y luego cada vez que se pulsa la tecla F. A continuación podremos ver la zona de confinamiento reducida de la cámara que sigue a B, y por último veremos la zona de confinamiento de la cámara que sigue a A y que deja de seguirlo cuando este cae por el agua (sale de la zona de confinamiento).

![alt text](https://github.com/RubnGB/ull_master_fundamentosDesarrollo/blob/main/Practica7/gif_animation_07b.gif)